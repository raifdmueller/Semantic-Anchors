= Rubber Duck Debugging
:categories: uncategorized
:roles: software-developer, qa-engineer

[%collapsible]
====
*Full Name*: Rubber Duck Debugging

*Core Concepts*:

* *Explain to Understand*: Articulating a problem aloud surfaces gaps in understanding
* *Step-by-Step Verbalization*: Force yourself to go through code/logic line by line
* *Assumption Surfacing*: Speaking aloud exposes implicit assumptions that may be wrong
* *No Expertise Required*: The "listener" (rubber duck, colleague, LLM) need not be an expert
* *Slowing Down*: The act of explaining forces a slower, more deliberate thought process
* *External Cognition*: Verbalizing creates an external representation that aids debugging
* *Self-Directed Learning*: Often the explainer solves the problem before finishing the explanation
* *Teaching to Learn*: Related to the Feynman Technique and learning-by-teaching principle

*Key Origin*: "The Pragmatic Programmer" by Andrew Hunt and David Thomas (1999), referencing earlier programmer folklore

*Historical Context*: Decades-old practice in programming culture, formalized and named in influential software engineering literature

*When to Use*:

* Debugging stubborn problems where you're stuck
* Code review where explaining to a colleague reveals issues
* Learning new concepts by teaching them to someone (or something) else
* Validating understanding of complex systems or algorithms
* When rubber-ducking to an LLM, explicitly adopting this frame to trigger step-by-step explanation

*Related Concepts*:

* Pair programming (where explaining is continuous)
* <<feynman-technique,Feynman Technique>> (learning by simple explanation)
* <<socratic-method,Socratic Method>> (when the duck asks questions back)
====
