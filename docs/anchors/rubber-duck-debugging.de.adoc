= Rubber Duck Debugging
:categories: problem-solving
:roles: software-developer, qa-engineer

[%collapsible]
====
*Vollständiger Name*: Rubber Duck Debugging

*Kernkonzepte*:

* *Erklären zum Verstehen*: Lautes Artikulieren eines Problems macht Verständnislücken sichtbar
* *Schrittweise Verbalisierung*: Zwingt dazu, Code/Logik Zeile für Zeile durchzugehen
* *Annahmen sichtbar machen*: Lautes Sprechen legt implizite Annahmen offen, die falsch sein könnten
* *Keine Expertise erforderlich*: Der "Zuhörer" (Gummiente, Kollege, LLM) muss kein Experte sein
* *Verlangsamung*: Der Akt des Erklärens erzwingt einen langsameren, überlegteren Denkprozess
* *Externe Kognition*: Verbalisierung schafft eine externe Darstellung, die beim Debuggen hilft
* *Selbstgesteuertes Lernen*: Oft löst der Erklärende das Problem, bevor er die Erklärung beendet
* *Durch Lehren lernen*: Verwandt mit der Feynman-Technik und dem Lern-durch-Lehren-Prinzip

*Schlüsselursprung*: "The Pragmatic Programmer" von Andrew Hunt und David Thomas (1999), unter Bezugnahme auf ältere Programmiererfolklore

*Historischer Kontext*: Jahrzehntealte Praxis in der Programmierkultur, formalisiert und benannt in einflussreicher Software-Engineering-Literatur

*Wann zu verwenden*:

* Debugging hartnäckiger Probleme, bei denen man feststeckt
* Code-Review, bei dem das Erklären gegenüber einem Kollegen Probleme aufdeckt
* Lernen neuer Konzepte durch Lehren an jemanden (oder etwas) anderes
* Validierung des Verständnisses komplexer Systeme oder Algorithmen
* Beim Rubber-Ducking mit einem LLM, explizite Adoption dieses Rahmens, um schrittweise Erklärung auszulösen

*Verwandte Konzepte*:

* Pair Programming (wo Erklären kontinuierlich ist)
* <<feynman-technique,Feynman-Technik>> (Lernen durch einfache Erklärung)
* <<socratic-method,Sokratische Methode>> (wenn die Ente zurückfragt)
====
